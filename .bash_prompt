
# Prompt colors - normal
  blackTxt="\[\e[0;30m\]"
    redTxt="\[\e[0;31m\]"
  greenTxt="\[\e[0;32m\]"
 yellowTxt="\[\e[0;33m\]"
   blueTxt="\[\e[0;34m\]"
 purpleTxt="\[\e[0;35m\]"
   cyanTxt="\[\e[0;36m\]"
  whiteTxt="\[\e[0;37m\]"
# Prompt colors - bold

 blackBBld="\[\e[1;29m\]"
 blackBold="\[\e[1;30m\]"
   redBold="\[\e[1;31m\]"
 greenBold="\[\e[1;32m\]"
yellowBold="\[\e[1;33m\]"
  blueBold="\[\e[1;34m\]"
purpleBold="\[\e[1;35m\]"
  cyanBold="\[\e[1;36m\]"
 whiteBold="\[\e[1;37m\]"
# Prompt colors - underline
   blackUl="\[\e[4;30m\]"
     redUl="\[\e[4;31m\]"
   greenUl="\[\e[4;32m\]"
  yellowUl="\[\e[4;33m\]"
    blueUl="\[\e[4;34m\]"
  purpleUl="\[\e[4;35m\]"
    cyanUl="\[\e[4;36m\]"
   whiteUl="\[\e[4;37m\]"
# Prompt colors - background
     blackBg="\[\e[40m\]"
       redBg="\[\e[41m\]"
     greenBg="\[\e[42m\]"
    yellowBg="\[\e[43m\]"
      blueBg="\[\e[44m\]"
    purpleBg="\[\e[45m\]"
      cyanBg="\[\e[46m\]"
     whiteBg="\[\e[47m\]"
# Prompt colors - reset
   resetColor="\[\e[0m\]"


if [ "`id -u`" -eq 0 ]; then
    promptTitlebar=
    userHostPromptColor=${redTxt}
    dirPromptColor=${cyanTxt}
    promptSign="#"
else
    if [[ `uname -o` == 'Cygwin' ]]; then
        promptTitlebar='\[\e]0;\h - \w\a\]'
        userHostPromptColor=${greenTxt}
        dirPromptColor=${yellowTxt}
        promptSign=" \n\$"
    else 
        promptTitlebar=
        userHostPromptColor=${greenTxt}
        dirPromptColor=${blueBold}
        
        promptSign="\$"
    fi
fi

cmdPromptColor=${resetColor}${blackBBld}


###################################################################################################
# https://github.com/emilis/emilis-config/blob/master/.bash_ps1

# Fill with minuses
# (this is recalculated every time the prompt is shown in function prompt_command):
fill="--- "
reset_style='\[\033[00m\]'
if [ -z "$VIM" ];
then status_style=$reset_style'\[\033[0;90m\]' # gray color; use 0;37m for lighter color
else status_style=$reset_style'\[\033[0;90;107m\]'
fi


# Reset color for command output
# (this one is invoked every time before a command is executed):
#trap 'echo -ne "\e[0m"' DEBUG

function fill_prompt_command {
    # create a $fill of all screen width minus the time string and a space:
    let fillsize=${COLUMNS}-9
    fill=""
    while [ "$fillsize" -gt "0" ]
    do
        fill="-${fill}" # fill with underscores to work on
        let fillsize=${fillsize}-1
    done
    
    # If this is an xterm set the title to user@host:dir
    case "$TERM" in
    xterm*|rxvt*)
        bname=`basename "${PWD/$HOME/~}"`
        echo -ne "\033]0;${bname}: ${USER}@${HOSTNAME}: ${PWD/$HOME/~}\007"
        ;;
    *)
        ;;
    esac

    # Prompt variable:
    OLD_PS1="$PS1"
    PS1="$status_style"'$fill \t\n'"${resetColor}$OLD_PS1"
}


###################################################################################################
# https://raw.githubusercontent.com/matthewmccullough/dotfiles/master/bash_gitprompt

alias git='LANG=en_US git'

function parse_git_branch {
  git rev-parse --git-dir &> /dev/null
  git_status="$(git status 2> /dev/null)"
  
  branch_pattern="On branch ([^${IFS}]*)"
  branch_rebase_pattern="You are currently rebasing branch '([^${IFS}]*)'"
  remote_pattern="Your branch is (.*) '"
  diverge_pattern="Your branch and (.*) have diverged"
  clean_pattern="working directory clean"
  changes_pattern="Changes "
  
  if [[ ! ${git_status} =~ ${clean_pattern} ]]; then
    if [[ ${git_status} =~ ${changes_pattern} ]]; then
        state="${redTxt} ✘"
    else
        state="${yellowTxt} ✔"
    fi
  else 
    state="${greenTxt} ✔"
  fi
  
  # add an else if or two here if you want to get more specific
  if [[ ${git_status} =~ ${remote_pattern} ]]; then
    if [[ ${BASH_REMATCH[1]} == "ahead of" ]]; then
      remote="${greenTxt} ↑"
    else if [[ ${BASH_REMATCH[1]} == "behind" ]]; then
      remote="${yellowTxt} ↓"
    else
      remote="${greenTxt} ↔"
    fi
    fi
  fi
  
  if [[ ${git_status} =~ ${diverge_pattern} ]]; then
    remote="${yellowTxt} ↕"
  fi
  
  if [[ ${git_status} =~ ${branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  fi
  
  if [[ ${git_status} =~ ${branch_rebase_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
    state="${redTxt} ☈"
  fi

  if [[ ! -z ${branch} ]]; then
    echo " (${branch})${remote}${state}"    
  fi
}

function git_dirty_flag {
  git status 2> /dev/null | grep -c : | awk '{if ($1 > 0) print " Z"}'
}

function git_prompt_command {
    # linux style
    #prompt="${userHostPromptColor}\u@\h${whiteTxt}:${dirPromptColor}\w${purpleTxt}$(parse_git_branch)${resetColor}${promptSign} " 

    # Cygwin style
    #prompt="${promptTitlebar}${userHostPromptColor}\u@\h ${dirPromptColor}\w${purpleTxt}$(parse_git_branch)${resetColor}${promptSign} "
    prompt="${promptTitlebar}${userHostPromptColor}\u@\h ${dirPromptColor}\w ${resetColor}${promptSign} "

    PS1=${prompt}
}


###################################################################################################

function prompt_command {
    git_prompt_command
    fill_prompt_command
}

PROMPT_COMMAND=prompt_command
